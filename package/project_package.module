<?php

/**
 * @file project_package.module
 * Provides packages made up of releases of other projects.
 */

/**
 * Implement hook_views_api().
 */
function project_package_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'project_package') .'/views',
  );
}

/**
 * Implement hook_nodeapi().
 */
function project_package_nodeapi(&$node, $op, $arg) {
  switch ($node->type) {
    case 'project_release':
      project_package_release_nodeapi($node, $op, $arg);
      break;

  }
}

/**
 * hook_nodeapi implementation specific to "project_release" nodes.
 *
 * @see project_package_nodeapi().
 */
function project_package_release_nodeapi(&$node, $op, $arg) {
  switch ($op) {
    case 'insert':
    case 'update':
      // We can't rely on $node->project_package since nodeapi() doesn't have
      // a fully loaded $node object. :(
      $count = db_result(db_query("SELECT COUNT(*) FROM {project_package_local_release_item} WHERE package_nid = %d", $node->nid));
      if (!empty($count)) {
        project_package_set_update_status($node->nid);
      }
      break;

    case 'load':
      $count = db_result(db_query("SELECT COUNT(*) FROM {project_package_local_release_item} WHERE package_nid = %d", $node->nid));
      if (!empty($count)) {
        $node->project_package['count'] = $count;
      }
      break;

    case 'delete':
      project_package_clear_release_items($node->nid);
      break;

  }
}

/**
 * Set the {prn}.update_status for a package based on security updates.
 */
function project_package_set_update_status($package_nid) {
  $max = db_result(db_query("SELECT MAX(prn.update_status) FROM {project_release_nodes} prn INNER JOIN {project_package_local_release_item} pp ON prn.nid = pp.item_nid WHERE pp.package_nid = %d", $package_nid));
  if ($max == PROJECT_RELEASE_UPDATE_STATUS_NOT_SECURE) {
    // Something included in this package is insecure, so we are, too.
    db_query("UPDATE {project_release_nodes} SET update_status = %d WHERE nid = %d", PROJECT_RELEASE_UPDATE_STATUS_NOT_SECURE, $package_nid);
  }
}

/**
 * Fix the {prn}.update_status column whenever the status changes on items.
 */
function project_package_check_update_status($item_nids) {
  $affected_packages = array();
  $placeholders = db_placeholders($item_nids);
  $query = db_query("SELECT * FROM {project_package_local_release_item} WHERE item_nid IN ($placeholders) GROUP BY package_nid", $item_nids);
  while ($package = db_fetch_object($query)) {
    $affected_packages[] = $package->package_nid;
  }
  if (!empty($affected_packages)) {
    $placeholders = db_placeholders($affected_packages);
    db_query("UPDATE {project_release_nodes} SET update_status = %d WHERE nid IN ($placeholders)", array_merge(array(PROJECT_RELEASE_UPDATE_STATUS_NOT_SECURE), $affected_packages));
  }
}

/**
 * Record a remote item (or library) included in a given release.
 *
 * @param integer $package_nid
 *   The release node ID of the package to record the remote item for.
 *
 * @param string $item_url
 *   The fully qualified URL where the remote item lives.
 *
 * @param string $name
 *   A human readable name to be associated with the item.
 */
function project_package_record_remote_item($package_nid, $item_url, $name) {
  // Try to update an existing record, if any.
  $record = (object) array(
    'package_nid' => $package_nid,
    'url' => $item_url,
    'name' => $name,
  );

  $id = db_result(db_query("SELECT id FROM {project_package_remote_item} WHERE package_nid = %d AND url = '%s'", $record->package_nid, $record->url));
  if ($id) {
    $record->id = $id;
    $update = array('id');
  }
  else {
    $update = array();
  }

  drupal_write_record('project_package_remote_item', $record, $update);

  return $record->id;
}

/**
 * Remove all records containing package contents for a release node.
 */
function project_package_clear_release_items($nid) {
  db_query("DELETE FROM project_package_local_release_item WHERE package_nid = %d", $nid);
  db_query("DELETE FROM project_package_remote_item WHERE package_nid = %d", $nid);
}
